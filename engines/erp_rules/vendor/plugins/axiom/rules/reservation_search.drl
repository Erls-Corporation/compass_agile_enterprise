package com.tnsolutionsinc.compass
 
import org.apache.log4j.Logger;
import com.tnsolutionsinc.axiom.context.ExecutionContext;
import com.tnsolutionsinc.axiom.context.EnvironmentContext;
import com.tnsolutionsinc.axiom.context.CustomerContext;
import com.tnsolutionsinc.axiom.context.SearchContext;
import com.tnsolutionsinc.compass.model.ResultMap;
import com.tnsolutionsinc.compass.erp.models.TimesharePtsOwnership;
import com.tnsolutionsinc.compass.erp.models.Agreement;
import java.util.Date;
import java.util.Calendar;
import java.util.ArrayList;
import java.util.HashMap;
import com.mdimension.jchronic.Chronic;
import com.mdimension.jchronic.Options;
import com.mdimension.jchronic.utils.Span;

 /*
 # input: TimesharePtsOwnership instance
    # output: hash of parameters that will help filter the inventory search
    # to produce inventory intervals for the owner's contracted unit during 
    # the contracted week:
    #    :resort_id 
    #    :accomodation_unit_type_id 
    #    :accomodation_unit_id 
    #    :reservation_intervals, an array of hashes containing:
    #        :check_in_date (Date) 
    #        :length of stay (in days)  
   
    */
rule "HomeAccess"
    // activate rule when the search context is in working memory
    // search context contains a search tyep == "HOME_ACCESS"
    // the customer context is in working memory and its ownership is not null
    // also make sure the resultMap is in working memory and assign it to resultMap
    when
        searchContext : SearchContext()
        eval(searchContext.get("search_type").toString().equals("Home Access"))
        customerContext : CustomerContext();
        eval(customerContext.get("ownership") != null)
        resultMap : ResultMap()
    then
      Logger logger = Logger.getLogger("com.tnsolutionsinc.rule.ReservationSearch");
      logger.debug("FIRED Home Access");
    
      TimesharePtsOwnership ownership = (TimesharePtsOwnership)customerContext.get("ownership");
      logger.debug( "Search type ="+searchContext.get("search_type") );
        
      // home access requires global access contract
      logger.debug("ownership.agreement.agreementType.internalIdentifier="+ownership.agreement.agreementType.internalIdentifier.toString()); 
      if (!ownership.agreement.agreementType.internalIdentifier.toString().equals("global_access")){
       return ;
      }

      // home access requires week type of Fixed or Fixed Float
      boolean valid = false;
      if(ownership.accommodationInvItem.weekType.toString().equals("Fixed"))
        valid = true;
      else if(ownership.accommodationInvItem.weekType.toString().equals("Fixed Float"))
        valid = true;
      else if(ownership.accommodationInvItem.resort.internalIdentifier.equals("snowdance") 
              && (ownership.accommodationInvItem.weekNumber == 7 
               || ownership.accommodationInvItem.weekNumber == 52) )
        valid = true;
      
      if (!valid) {
        return;
      }
      
        // home access bookable 366 to 1095 days out
      Span earliest_check_in_date = Chronic.parse("366 days from now");
      logger.debug("366 days from now:"+earliest_check_in_date.getBeginCalendar().getTime());
      Span latest_check_in_date = Chronic.parse("1095 days from now");
      logger.debug("1095 days from now:"+latest_check_in_date.getBeginCalendar().getTime());
      
      // get all time intervals available for them to book as Home Access 
      int week_number =  ownership.accommodationInvItem.weekNumber ;
      logger.debug("week number:"+week_number );
      
      String check_in_day_of_week = ownership.accommodationInvItem.checkInDay;
      logger.debug("check_in_day_of_week:"+check_in_day_of_week );
   
      ArrayList reservation_intervals = new ArrayList();
      
      int earliest_year=earliest_check_in_date.getBeginCalendar().get(Calendar.YEAR);
      int latest_year=latest_check_in_date.getBeginCalendar().get(Calendar.YEAR);
      
      for(int year = earliest_year;year<=latest_year;year++){
        logger.debug("processing YEAR:"+year);
        String frequency = ownership.accommodationInvItem.frequency.toLowerCase();
		if (frequency.equals("annual")) {
		  if (frequency.equals("odd") && ((year % 2) == 0)) {
		    continue;
		  } 
		  else if (frequency.equals("even") && ((year % 2) == 1)) {
		    continue;
		  }
		}
        
        Date check_in_date = getCheckInDate(logger, year, week_number, check_in_day_of_week);
        HashMap checkInMap=new HashMap();
        checkInMap.put("check_in_date",check_in_date);
        checkInMap.put("length_of_stay",7);
        logger.debug("checkInMap:"+checkInMap);
        reservation_intervals.add(checkInMap);
      }  
      
      resultMap.put("ownership_id",ownership.id);
      resultMap.put("resort_id",ownership.accommodationInvItem.resort.id);
      resultMap.put("accomodation_unit_type_id",ownership.accommodationInvItem.accommodationUnit.accommodationUnitType.id);
      resultMap.put("accomodation_unit_id",ownership.accommodationInvItem.accommodationUnit.id);
      resultMap.put("accomodation_inv_item_id",ownership.accommodationInvItem.id);
      resultMap.put("reservation_intervals", reservation_intervals);
      resultMap.put("agreement_id",ownership.agreement.id);
         
end

/*
 **********************
 * Resort Access Rule *
 **********************  

     
*/
rule "ResortAccess"
    
    when
        searchContext : SearchContext()
        eval(searchContext.get("search_type").toString().equals("Resort Access"))
        customerContext : CustomerContext();
        eval(customerContext.get("ownership") != null)
        resultMap : ResultMap()
    then
        Logger logger = Logger.getLogger("com.tnsolutionsinc.rule.ReservationSearch");
        logger.debug("FIRED Resort  Access");
        TimesharePtsOwnership ownership = (TimesharePtsOwnership)customerContext.get("ownership");
        
        
     // resort access requires global access contract
           
         logger.debug("ownership.agreement.agreementType.internalIdentifier="+ownership.agreement.agreementType.internalIdentifier.toString()); 
        if (!ownership.agreement.agreementType.internalIdentifier.toString().equals("global_access")){
         return ;
        }
        
        
        // resort access requires week type of Fixed 
      if (!ownership.accommodationInvItem.weekType.toString().equals("Fixed")   ) {
        return ;         
      }
      
       // Resort Access booking window is 304 to 365 days prior to check-in date
      Span earliest_check_in_date_span = Chronic.parse("304 days from now");
      logger.debug("304 days from now:"+earliest_check_in_date_span.getBeginCalendar().getTime());
      Span latest_check_in_date_span = Chronic.parse("365 days from now");
      logger.debug("365 days from now:"+latest_check_in_date_span.getBeginCalendar().getTime());
      
      // get all time intervals available for them to book as Home Access 
      int week_number =  ownership.accommodationInvItem.weekNumber ;
      logger.debug("week number:"+week_number );
      
      String check_in_day_of_week = ownership.accommodationInvItem.checkInDay;
      logger.debug("check_in_day_of_week:"+check_in_day_of_week );
      
      Date earliest_check_in_date=earliest_check_in_date_span.getBeginCalendar().getTime();
      Date latest_check_in_date=latest_check_in_date_span.getBeginCalendar().getTime();
      
      //ArrayList reservation_intervals = new ArrayList();
        
       
      //HashMap checkInMap=new HashMap();
      //checkInMap.put("min_check_in_date",earliest_check_in_date);
     // checkInMap.put("max_check_in_date",latest_check_in_date);
     // checkInMap.put("min_length_of_stay",7);
      //reservation_intervals.add(checkInMap);
      resultMap.put("resort_id",ownership.accommodationInvItem.resort.id);
      resultMap.put("min_check_in_date",earliest_check_in_date);
      resultMap.put("max_check_in_date",latest_check_in_date);
      resultMap.put("min_length_of_stay",7);
      
      
      //resultMap.put("accomodation_unit_type_id",ownership.accommodationInvItem.accommodationUnit.accommodationUnitType.id);
     // resultMap.put("accomodation_unit_id",ownership.accommodationInvItem.accommodationUnit.id);
     // resultMap.put("accomodation_inv_item_id",ownership.accommodationInvItem.id);
     // resultMap.put("reservation_intervals", reservation_intervals);
     // resultMap.put("agreement_id",ownership.agreement.id);
    //  resultMap.put("agreement_eid",ownership.agreement.externalIdentifier);
     // resultMap.put("check_in_day",ownership.accommodationInvItem.checkInDay);
         
end

/*
 produces a date that matches a year, timeshare week-number, and check-in day of week string, like 'Friday'
*/

function Date getCheckInDate(Logger logger,int year, int week_number, String checkin_in_day_of_week){
    // create a calendar instance to use as the future date
    Calendar optionsCalendar=Calendar.getInstance();
    //set the optionCalendar to jan 1 of the year supplied
    optionsCalendar.set(Calendar.YEAR,year);
    optionsCalendar.set(Calendar.MONTH,Calendar.JANUARY);
    optionsCalendar.set(Calendar.DAY_OF_MONTH,1);
    // now create the options to pass into the Chronic parse
    Options chronicOptions = new Options(optionsCalendar);
    // parse the date
    Span span=Chronic.parse("1st "+checkin_in_day_of_week+" in January",chronicOptions);
    logger.debug("checkindate original"+span.getBeginCalendar().getTime());
    // calculate the day of year offset
    int offset=(week_number-1)*7;
    // create a calendar instance to contain the offset
    Calendar calendar_offset=span.getBeginCalendar();
    calendar_offset.add(Calendar.DAY_OF_YEAR,offset);
    logger.debug("checkindate offset"+calendar_offset.getTime());
    
    if(calendar_offset.get(Calendar.YEAR)==year){
        return calendar_offset.getTime();
    }else{
    
     return null;
    }
     
}


 