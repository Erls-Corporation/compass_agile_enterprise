package com.tnsolutionsinc.compass
 
import org.apache.log4j.Logger;
import com.tnsolutionsinc.axiom.context.ExecutionContext;
import com.tnsolutionsinc.axiom.context.EnvironmentContext;
import com.tnsolutionsinc.axiom.context.CustomerContext;
import com.tnsolutionsinc.axiom.context.SearchContext;
import com.tnsolutionsinc.compass.model.ResultMap;
import com.tnsolutionsinc.compass.erp.models.TimesharePtsOwnership;
import com.tnsolutionsinc.compass.erp.models.Agreement;
import java.util.Date;
import com.mdimension.jchronic.Chronic;
import com.mdimension.jchronic.Options;
import com.mdimension.jchronic.utils.Span;

/*
 # input: TimesharePtsOwnership instance
    # output: hash of parameters that will help filter the inventory search
    # to produce inventory intervals for the owner's contracted unit during 
    # the contracted week:
    #    :resort_id 
    #    :accomodation_unit_type_id 
    #    :accomodation_unit_id 
    #    :reservation_intervals, an array of hashes containing:
    #        :check_in_date (Date) 
    #        :length of stay (in days)  
    def process_home_access_rules(ownership)

      # home access requires global access contract
      if (ownership.agreement.agreement_type.internal_identifier != 'global_access')
        return nil
      end

      # home access requires week type of Fixed or Fixed Float
      if (ownership.accomodation_inv_item.week_type != 'Fixed' && 
          ownership.accomodation_inv_item.week_type != 'Fixed Float')
        return nil        
      end

      # home access bookable 366 to 1095 days out
      earliest_check_in_date = Date.today + 366.days
      latest_check_in_date = Date.today + 1095.days

      # get all time intervals available for them to book as Home Access 
      week_number = ownership.accomodation_inv_item.week_number
      check_in_day_of_week = ownership.accomodation_inv_item.check_in_day
      reservation_intervals = []
      (earliest_check_in_date.year..latest_check_in_date.year).each do |year|
        check_in_date = get_check_in_date(year, week_number, check_in_day_of_week)
        reservation_intervals << {:check_in_date => check_in_date,
                              :length_of_stay => 7}
      end
      
      return {
        :resort_id => ownership.accomodation_inv_item.resort.id,
        :accomodation_unit_type_id => ownership.accomodation_inv_item.accomodation_unit.accomodation_unit_type_id,
        :accomodation_unit_id => ownership.accomodation_inv_item.accomodation_unit.id,
        :accomodation_inv_item_id => ownership.accomodation_inv_item_id,
        :reservation_intervals => reservation_intervals,
        :agreement_id => ownership.agreement.id
      }
    end

*/
rule "HomeAccess"
    // activate rule when the search context is in working memory
    // search context contains a search tyep == "HOME_ACCESS"
    // the customer context is in working memory and its ownership is not null
    // also make sure the resultMap is in working memory and assign it to resultMap
	when
	    searchContext : SearchContext()
	    eval(searchContext.get("SEARCH_TYPE").toString().equals("HOME_ACCESS")) 
	    customerContext : CustomerContext();
        eval(customerContext.get("OWNERSHIP") != null)
		resultMap : ResultMap()
	then
	    Logger logger = Logger.getLogger("com.tnsolutionsinc.rule.HomeAccess");
	    logger.debug("FIRED Home Access");
	
	    TimesharePtsOwnership ownership = (TimesharePtsOwnership)customerContext.get("OWNERSHIP");
		logger.debug( "Search type ="+searchContext.get("SEARCH_TYPE") );
		
		String reservation_intervals ="NOT IMPLEMENTED YET";

                // rule fired is now handled in the RuleExecutor so it no longer has to be set here
		//resultMap.put("rule fired",searchContext.get("SEARCH_TYPE").toString());
		
		resultMap.put("resort_id",ownership.accommodationInvItem.resort.id);
		resultMap.put("accommodation_unit_type_id",ownership.accommodationInvItem.accommodationUnit.accommodationUnitType.id);
		resultMap.put("accomodation_unit_id",ownership.accommodationInvItem.accommodationUnit.id);
		resultMap.put("accomodation_inv_item_id",ownership.accommodationInvItem.id);
		resultMap.put("reservation_intervals", reservation_intervals);
		resultMap.put("agreement_id",ownership.agreement.id);
		Span span = Chronic.parse("tomorrow");
		resultMap.put("span",span.toString());
		
		
		//test we can invoke functions
		resultMap.put("check-in.date",getCheckInDate(0,0,0));
		 
end
/*
def process_resort_access_rules(ownership)

      # resort access requires global access contract
      if (ownership.agreement.agreement_type.internal_identifier != 'global_access')
        return nil
      end

      # resort access requires week type of Fixed - doublecheck this, rules and requirements doc isn't completely clear on this
      if (ownership.accomodation_inv_item.week_type != 'Fixed' )
        return nil        
      end

      # Resort Access booking window is 304 to 365 days prior to check-in date
      earliest_check_in_date = Date.today + 304.days
      latest_check_in_date = Date.today + 365.days

      # get all time intervals available for them to book as Resort Access , there are exceptions not added yet
      week_number = ownership.accomodation_inv_item.week_number
      check_in_day_of_week = ownership.accomodation_inv_item.check_in_day
      reservation_intervals = []
      (earliest_check_in_date.year..latest_check_in_date.year).each do |year|
        check_in_date = get_check_in_date(year, week_number, check_in_day_of_week)
        reservation_intervals << {:check_in_date => check_in_date,
                              :length_of_stay => 7}
      end
      
      return {
        :resort_id => ownership.accomodation_inv_item.resort.id,
        :accomodation_unit_type_id => ownership.accomodation_inv_item.accomodation_unit.accomodation_unit_type_id,
        :accomodation_unit_id => ownership.accomodation_inv_item.accomodation_unit.id,
        :accomodation_inv_item_id => ownership.accomodation_inv_item_id,
        :reservation_intervals => reservation_intervals,
        :agreement_id => ownership.agreement_id,
        :agreement_eid => ownership.agreement.external_identifier
      }
    end
    */
rule "ResortAccess"
    
	when
	    searchContext : SearchContext()
	    eval(searchContext.get("SEARCH_TYPE").toString().equals("RESORT_ACCESS")) 
	    customerContext : CustomerContext();
        eval(customerContext.get("OWNERSHIP") != null)
		resultMap : ResultMap()
	then
	    Logger logger = Logger.getLogger("com.tnsolutionsinc.rule.ResortAccess");
	    logger.debug("FIRED Home Access");
		TimesharePtsOwnership ownership = (TimesharePtsOwnership)customerContext.get("OWNERSHIP");
		//System.out.println( "Search type ="+searchContext.get("SEARCH_TYPE").toString() );
		
		String reservation_intervals ="NOT IMPLEMENTED YET coming soon to a server near you";
// rule fired is now handled in the RuleExecutor so it no longer has to be set here
		//resultMap.put("rule fired",searchContext.get("SEARCH_TYPE"));
		resultMap.put("check-in.date",getCheckInDate(0,0,0));
		
		resultMap.put("resort_id",ownership.accommodationInvItem.resort.id);
		resultMap.put("accommodation_unit_type_id",ownership.accommodationInvItem.accommodationUnit.accommodationUnitType.id);
		resultMap.put("accomodation_unit_id",ownership.accommodationInvItem.accommodationUnit.id);
		resultMap.put("accomodation_inv_item_id",ownership.accommodationInvItem.id);
		resultMap.put("reservation_intervals", reservation_intervals);
		resultMap.put("agreement_id",ownership.agreement.id);
		resultMap.put("agreement_eid",ownership.agreement.externalIdentifier);
		 
end

/*
# produces a date that matches a year, timeshare week-number, and check-in day of week string, like 'Friday'
    def get_check_in_date(year, week_number, check_in_day_of_week)
      time = Chronic.parse("1st #{check_in_day_of_week} in January", {:now => Time.utc(year,"jan",1,0,0,0)})
      time = time + (7.days*(week_number-1))
      if (time.year == year)
        return Date.new(time.year, time.month, time.day)
      else
        return nil
      end
    end
    */
function Date getCheckInDate(int year, int week_number, int checkin_in_day_of_week){
	return new Date();
}


 